<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weeelly VS Evil Tommy</title>
</head>
<style>
    body {margin:0}
    p {margin-left:40px}
</style>
<body>
    <canvas id="surface"></canvas>
    <p>Press F to enter full screen</p>
</body>
<script>
const [W,H] = [640,480]
const canvas = document.getElementById('surface')
canvas.width = W
canvas.height = H
const ctx = canvas.getContext('2d')
ctx.imageSmoothingEnabled = false
const keys = {
    ArrowLeft:{pressed:false},
    ArrowRight:{pressed:false},
}
function renderClear(x=0,y=0,w=W,h=H) {
    ctx.clearRect(x,y,w,h)
}
function renderRect(x,y,w,h,color) {
    ctx.fillStyle = color
    ctx.fillRect(x,y,w,h)
}
function renderCirle(x,y,r,color) {
    ctx.fillStyle = color
    ctx.beginPath()
    ctx.arc(x,y,r,0,2*Math.PI)
    ctx.fill()
}
function renderText(text,x,y,color,size=20) {
    ctx.fillStyle = color
    ctx.font = size+'px sans-serif'
    ctx.fillText(text,x,y)
}
function checkCollision(a,b) {
    return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y
}
function random(min,max) {
    return Math.floor(Math.random()*(max-min+1)+min)
}
const BOUND = 60
const PLAYER_SIZE = 80
const TEXT_PARTICLE_SPAN = 50
const TEXT_PARTICLE_SIZE = 30
const COLORS = [
    '#8CF',
    '#4AF',
    '#028',
]
const items_values = {
    screw:5,
    monitor:10,
    cpu:20,
    bomb:-10,
}
class Player {
    constructor(x,y) {
        this.x = x
        this.y = y
        this.w = PLAYER_SIZE
        this.h = PLAYER_SIZE
        this.color = 'red'
        this.speed = 5
        this.after_hit = false
    }
    render() {
        if(this.after_hit) {
            blink_tick++
            if((Math.floor(blink_tick/8)+1)%2==0) 
                ctx.drawImage(sprites.weeelly,this.x,this.y,this.w,this.h)
        }
        else ctx.drawImage(sprites.weeelly,this.x,this.y,this.w,this.h)
    }
    update() {
        if(keys.ArrowLeft.pressed && this.x>BOUND)
            this.x -= this.speed
        if(keys.ArrowRight.pressed && this.x+this.w<W-BOUND)
            this.x += this.speed
    }
}
class Enemy extends Player {
    constructor(x,y) {
        super(x,y)
        this.color = 'blue'
    }
    render() {
        ctx.drawImage(sprites.evil_tommy,this.x,this.y,this.w,this.h)
    }
    update() {
        this.x += this.speed
        if(this.x<BOUND || this.x+this.w>W-BOUND)
            this.speed *= -1
    }
}
class Item {
    constructor(x,type) {
        this.x = x
        this.y = PLAYER_SIZE
        this.w = 32
        this.h = 32
        this.color = 'green'
        this.speed = level*2
        this.type = type
        this.value = items_values[type]
    }
    render() {
        ctx.drawImage(sprites[this.type],this.x,this.y,this.w,this.h)
    }
    update() {
        this.y += this.speed
    }
}
class Bomb extends Item {
    constructor(x) {
        super(x,'bomb')
        this.color = 'black'
        this.speed = level*4
    }
}
class TextParticle {
    constructor(x,text,color) {
        this.x = x
        this.y = H-PLAYER_SIZE
        this.text = text
        this.color = color
        this.speed = 2
    }
    render() {
        renderText(this.text,this.x,this.y,this.color,TEXT_PARTICLE_SIZE)
    }
    update() {
        this.y -= this.speed
    }
}
class BackgroundParticle {
    constructor(type,x,y=-12*8) {
        this.type = type
        this.x = x
        this.y = y
        this.w = {'cloud':24*8,'star':4}[type]
        this.h = {'cloud':12*8,'star':4}[type]
        this.speed = {'cloud':10,'star':15}[type]
    }
    render() {
        if(this.type=='cloud') ctx.drawImage(sprites.cloud,this.x,this.y,this.w,this.h)
        if(this.type=='star') renderRect(this.x,this.y,this.w,this.h,'lightyellow')
    }
    update() {
        this.y += this.speed
    }
}
let weeelly = new Player(W/2,H-PLAYER_SIZE)
let evil_tommy = new Enemy(W/2,0)
let level = 1
let items_and_bombs = []
let life = 3
let score = 0
let text_particles = []
let clouds = [
    new BackgroundParticle('cloud',random(-24*4,W+24*4),0),
    new BackgroundParticle('cloud',random(-24*4,W+24*4),H*1/3),
    new BackgroundParticle('cloud',random(-24*4,W+24*4),H*2/3),
]
let stars = []
let blink_tick = 0
function loop() {
    /* Render */
    renderRect(0,0,W,H,COLORS[level-1])
    if(level==1 || level==2) {
        clouds.forEach(cloud => cloud.render())
    }
    if(level>2) {
        stars.forEach(star => star.render())
    }
    weeelly.render()
    evil_tommy.render()
    items_and_bombs.forEach(item => item.render())
    text_particles.forEach(tp => tp.render())
    for(let i=0;i<3;i++)
        ctx.drawImage(sprites.life_empty,20,H/2-i*40,32,32)
    for(let i=0;i<life;i++)
        ctx.drawImage(sprites.life,20,H/2-i*40,32,32)
    renderRect(W-40,H-40,20,-10-4*100,'grey')
    renderRect(W-40,H-40,20,-10-4*score,'green')
    /* Update */
    if(level==1 || level==2) {
        if(Math.random()<0.05) {
            clouds.push(new BackgroundParticle('cloud',random(-24*4,W+24*4)))
        }
        clouds.forEach(cloud => cloud.update())
        clouds = clouds.filter(cloud => cloud.y<H)
    }
    if(level>2) {
        if(Math.random()<0.5) {
            stars.push(new BackgroundParticle('star',random(0,W)))
        }
        stars.forEach(star => star.update())
        stars = stars.filter(star => star.y<H)
    }
    weeelly.update()
    evil_tommy.update()
    items_and_bombs.forEach(item => item.update())
    items_and_bombs = items_and_bombs.filter(elem => elem.y<H)
    if(Math.random()<0.01) {
        if(Math.random()<0.8)
            items_and_bombs.push(new Item(evil_tommy.x+PLAYER_SIZE/2,['screw','monitor','cpu'][random(0,2)]))
        else
            items_and_bombs.push(new Bomb(evil_tommy.x+PLAYER_SIZE/2))
    }
    items_and_bombs.forEach(item => {
        if(checkCollision(weeelly,item)) {
            score += item.value
            if(score<0)
                score = 0
            if(item.type=='bomb' && !weeelly.after_hit) {
                life--
                text_particles.push(new TextParticle(weeelly.x,item.value,'red'))
                weeelly.after_hit = true
                setTimeout(() => {
                    weeelly.after_hit = false
                    blink_tick = 0
                },1500)
            } else {
                text_particles.push(new TextParticle(weeelly.x,'+'+item.value,'green'))
            }
            items_and_bombs = items_and_bombs.filter(elem => elem!=item)
        }
    })
    text_particles.forEach(tp => {
        tp.update()
        if(tp.y<H-PLAYER_SIZE-TEXT_PARTICLE_SPAN)
            text_particles = text_particles.filter(elem => elem!=tp)
    })
    if(life<=0) {
        alert('Game Over! Your score is: '+score)
        location.reload()
    }
    if(score>=100) {
        alert('You win!')
        location.reload()
    }
    requestAnimationFrame(loop)
}
const sprites = {
    weeelly:document.createElement('img'),
    evil_tommy:document.createElement('img'),
    life:document.createElement('img'),
    life_empty:document.createElement('img'),
    screw:document.createElement('img'),
    monitor:document.createElement('img'),
    cpu:document.createElement('img'),
    bomb:document.createElement('img'),
    cloud:document.createElement('img'),
}
for(let sprite in sprites)
    sprites[sprite].src = 'res/'+sprite+'.png'
addEventListener('keydown',({key}) => {
    if(key in keys && keys[key].pressed==false)
        keys[key].pressed = true
    if(key=='f')
        canvas.requestFullscreen()
    if(key>=1 && key<=3) level = key
})
addEventListener('keyup',({key}) => {
    if(key in keys)
        keys[key].pressed = false
})
addEventListener('load',loop)
</script>